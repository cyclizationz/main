--- a/hw/usb/dev-hid.c	2023-12-12 00:00:00.000000000 +0000
+++ b/hw/usb/dev-hid.c	2025-10-17 00:00:00.000000000 +0000
@@ -27,6 +27,7 @@
 #include "hw/usb/hid.h"
 #include "hw/qdev-properties.h"
 #include "qom/object.h"
+#include "chardev/char-fe.h"
 
 struct USBHIDState {
     USBDevice dev;
@@ -36,6 +37,12 @@
     uint32_t usb_version;
     char *display;
     uint32_t head;
+
+    /* socket-backed keyboard ingest */
+    CharBackend kbd_chr;
+    uint8_t kbd_sock_buf[16];
+    size_t kbd_sock_len;
+    bool kbd_chr_inited;
 };
 
 #define TYPE_USB_HID "usb-hid"
@@ -294,6 +301,69 @@ static const uint8_t qemu_keyboard_hid_report_descriptor[] = {
     0xc0,                          /* End Collection */
 };
 
+/* ---- usb-kbd socket backend glue -------------------------------------- */
+/* Apply an 8-byte USB boot keyboard report to HID keyboard state. */
+static void usb_hid_kbd_apply_report(USBHIDState *us, const uint8_t rep[8])
+{
+    HIDState *hs = &us->hid;
+    int i, cnt = 0;
+
+    /* rep[0]=modifiers, rep[1]=reserved, rep[2..7]=keycodes */
+    hs->kbd.modifiers = rep[0];
+
+    memset(hs->kbd.key, 0, sizeof(hs->kbd.key));
+    for (i = 2; i < 8; i++) {
+        if (rep[i]) {
+            if (cnt < sizeof(hs->kbd.key)) {
+                hs->kbd.key[cnt] = rep[i];
+            }
+            cnt++;
+        }
+    }
+    hs->kbd.keys = MIN(cnt, (int)sizeof(hs->kbd.key));
+
+    /* We are snapshotting state, not building a scancode queue. */
+    hs->n = 0;
+    hs->idle_pending = false;
+
+    /* Wake the interrupt endpoint so the guest polls and sees new data. */
+    usb_hid_changed(hs);
+}
+
+static int kbd_chr_can_read(void *opaque)
+{
+    USBHIDState *us = opaque;
+    return sizeof(us->kbd_sock_buf) - us->kbd_sock_len;
+}
+
+static void kbd_chr_read(void *opaque, const uint8_t *buf, int size)
+{
+    USBHIDState *us = opaque;
+
+    while (size > 0 && us->kbd_sock_len < sizeof(us->kbd_sock_buf)) {
+        us->kbd_sock_buf[us->kbd_sock_len++] = *buf++;
+        size--;
+        if (us->kbd_sock_len >= 8) {
+            usb_hid_kbd_apply_report(us, us->kbd_sock_buf);
+            /* shift the buffer in case caller pipelined multiple reports */
+            memmove(us->kbd_sock_buf, us->kbd_sock_buf + 8,
+                    us->kbd_sock_len - 8);
+            us->kbd_sock_len -= 8;
+        }
+    }
+}
+
+static void kbd_chr_event(void *opaque, QEMUChrEvent event)
+{
+    (void)opaque; (void)event;
+}
+
@@ -370,8 +440,13 @@ static void usb_hid_unrealize(USBDevice *dev)
 {
     USBHIDState *us = USB_HID(dev);
     hid_free(&us->hid);
+    if (us->kbd_chr_inited) {
+        /* Detach frontend handlers; do not close user's backend. */
+        qemu_chr_fe_deinit(&us->kbd_chr, false);
+        us->kbd_chr_inited = false;
+    }
 }
 
@@ -407,6 +482,20 @@ static void usb_keyboard_realize(USBDevice *dev, Error **errp)
 {
     usb_hid_initfn(dev, HID_KEYBOARD, &desc_keyboard, &desc_keyboard2, errp);
+
+    /* If a chardev was attached, consume 8-byte keyboard reports from it. */
+    USBHIDState *us = USB_HID(dev);
+    us->kbd_sock_len = 0;
+    if (qemu_chr_fe_backend_connected(&us->kbd_chr)) {
+        qemu_chr_fe_set_handlers(&us->kbd_chr,
+                                 kbd_chr_can_read,
+                                 kbd_chr_read,
+                                 kbd_chr_event,
+                                 NULL,
+                                 us,
+                                 NULL,
+                                 true);
+        us->kbd_chr_inited = true;
+    }
 }
 
 static int usb_ptr_post_load(void *opaque, int version_id)
@@ -488,10 +577,12 @@ static const TypeInfo usb_mouse_info = {
     .class_init = usb_mouse_class_initfn,
 };
 
-static Property usb_keyboard_properties[] = {
+static Property usb_keyboard_properties[] = {
     DEFINE_PROP_UINT32("usb_version", USBHIDState, usb_version, 2),
     DEFINE_PROP_STRING("display", USBHIDState, display),
+    /* New: attach a chardev to feed raw 8-byte HID keyboard reports */
+    DEFINE_PROP_CHR("chardev", USBHIDState, kbd_chr),
     DEFINE_PROP_END_OF_LIST(),
 };
